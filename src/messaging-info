This file explains messaging protocol used in this project and gives raw
specifications. For implementing a node using this protocol, this document may
not be enough, so consider example implementation in messaging.c or contact
anybody who was developing this protocol.

Initial development of this protocol was done by Morphe
                                                   (contact morpheby@gmail.com).

Later contributions:

*******************************************************************************

VERSION:
    0.2alpha -- Changed LOCK message, removed UNLOCK message.
                Changed locking policy
                Added CONTROL_ON and CONTROL_OFF instead of CONTROL
                REQUEST, CONTROL_ON and CONTROL_OFF now provide resource ID
                READY message provides resource ID

VERSION HISTORY:
    0.1  -- only initial design concept. Never tried to implement

*******************************************************************************

Basic terms:
    MCU - microcontroller node. Typical implementation is in messaging.c.
    PC  - PC node.
    Global address - address, all nodes will accept.
    Node address   - address of a single node, only one node shall accept it.
    Node table     - table with adresses of all nodes on the network

NOTE:
  Bit addressing is from the least significant bit to the highest significant.

*******************************************************************************

INTRODUCTION

... If you know what to write here, than do it :) But I personally prefer to
write technical details.

Well, this protocol mainly defines how to search for devices responsible for
collecting and providing named data.

 -- Example 1 "Measuring power"
  The network consists of two nodes - one devices is responsible for measuring
current and another for measuring voltage. So consider one device's measurements
are named "I" and another one's "U". So there may be a PC node connected to the
network or one or more devices with additional program for requesting "U", "I",
multiplying them and displaying the result. This program shall request
synchronisation and then request start of measurement. After some time, or maybe
never (this is irrelevant, data shall be collected asynchronously, overwriting
too old data) it requests stop of measurement and then requests both "U" and
"I" (if it has one of this itself, it shall not ask - it will have no reply).
Now it has all neccessary information and can compute and display the result.

Devices usually have control switches. If they are not programmed, they are
named and may be accessed in the same manner.

*******************************************************************************

TECHNICAL NOTES

1. Node table. Each node stores a table of addresses of all the nodes, however,
it is strongly recommended that each node has EXACTLY the same table (with the
same order of addresses) and, of course, contains the address of that node
itself. There are two ways of doing this. First is to sort addresses, and the
second is to store them in the order of registration.

*******************************************************************************

PACKET

    MSGTYPE_FULL - message type info (1 byte)
        [0-6] - MSGTYPE
                0x00 - READY
                0x01 - ERROR
                0x02 - PREREG
                0x03 - LOCK
                0x05 - NETINFO
                0x06 - FIND
                0x07 - DATA
                0x08 - REQUEST
                0x09 - CONTROL
                0x0A - NAMECHK
                0x0B - REG
                0x7F - RETRY
        [7]   - 0 if local message, 1 if global
    SRCADDR    - address of the source node
    XORSUM - 32-bits, used to check consistensy of the message
    PACKXORSUM - 32-bits, used to check consistensy of the data
    PARAM - 16-bits (usually length of the following data)
    {any data if neccessary by PARAM}

*******************************************************************************

PROTOCOL ITSELF

 READY message:
    PARAM = 0

 ERROR message:
    PARAM = 0

 LOCK message:
    PARAM = 0 to unlock and 1 to lock

 PREREG message:
    // This global message requests network information, the node shall reply
    // with NETINFO message, but, it's definetely better if only one node will
    // reply. How? By the time I was writing it, I didn't know. If I found, see
    // my implementation
    SRCADDR = 0x00
    PARAM   = 0

 NETINFO message:
    // This message is sent as global, however all nodes that are already
    // registered shall ignore it, cause it is intended for new node without
    // address
    SRCADDR = address of the source node
    PARAM   = legth of the array containing all the node adresses
    .addrs[PARAM/sizeof(addr_t)] - addresses of all the registered nodes
       (including the node which sent the message)

 REG message:
    // This is a global message, all devices are to accept and process this
    // message. SRCADDR shall be stored in nodes table
    SRCADDR = address of the newly registered node
    PARAM   = 0

 FIND message:
    PARAM = legth of the name to find
    .name[PARAM] - name to find

 DATA mesasge
    PARAM = legth of the data
    .data[PARAM] - data

 REQUEST message:
    PARAM = 0

 CONTROL message
    PARAM = 0 to switch off, 1 to switch on

 NAMECHK
    // If a node, which recieved this message already has its name, it shall
    // reply with ERROR message
    PARAM = length of name
    .name[PARAM] - name to check

 RETRY message
    // Node, which recieves this message shall resend its last message
    // Usually it indicates XORSUM error
    PARAM = 0

A) New node wants to register
    1) User initiates registation from a node - all unregistered nodes ignore
       any data on the line
    2) Node, which is introducing itself, sends PREREG message
    3) In case it gets UNLOCK message, it retries
    3) One node in the network (shall be one with the lowest address) sends
       LOCK message, followed by the NETINFO message
    4) Now, as node knows all the network, it generates address that is unique
       to the network
    5) Node sends REG message, providing address it has chosen for itself. All
       nodes recieve this message and store new client to the table
    6) Right after registration, node shall discard ALL names stored in it.
       However, it can then reregister all theese names, but this may lead to
       non-determined state, with some names correct, and some clear because of
       overlap
    7) If the node completed its registration procedure and has nothing to say,
       it sends UNLOCK message


B) Node asks for information named $NAME
    1) Node sends FIND message providing $NAME
    2) Node which has this name (unique name on the network, ensured by name
       registration) sends READY message
    3) First node sends REQUEST message
    4) Second node broadcasts LOCK message, so that no device on the network
       may start transmission and then sends DATA message to the node which
       requested this data.
    3) Node which recieved broadcasts UNLOCK message (in case of error it sends
       RETRY message)

C) Node asks for switching output named $NAME
    1) ...
    2) Node which has this name, replies with READY message
    3) Node sends CONTROL message
    4) Another node replies with READY message if OK, ERROR in case of internal
       error, and RETRY in case of damaged packet

D) Node asks for registering $NAME to ensure there are no name conflicts
    1) Node sends $NAMECHECK message

*******************************************************************************

EXAMPLES

1. Simple MCU <-> MCU communication
2. Three or more MCU communication
3. MCU <-> PC communication
4. Two or more MCU with PC communication
(5). Any other communication examples were not tested and were not considered
     while designing.
